<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>28.&nbsp;Content Type and Transformation</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="multi_spring-cloud.html" title="Spring Cloud"><link rel="up" href="multi__spring_cloud_stream.html" title="Part&nbsp;IV.&nbsp;Spring Cloud Stream"><link rel="prev" href="multi__configuration_options.html" title="27.&nbsp;Configuration Options"><link rel="next" href="multi_schema-evolution.html" title="29.&nbsp;Schema evolution support"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">28.&nbsp;Content Type and Transformation</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="multi__configuration_options.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;IV.&nbsp;Spring Cloud Stream</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="multi_schema-evolution.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="contenttypemanagement" href="#contenttypemanagement"></a>28.&nbsp;Content Type and Transformation</h2></div></div></div><p>To allow you to propagate information about the content type of produced messages, Spring Cloud Stream attaches, by default, a <code class="literal">contentType</code> header to outbound messages.
For middleware that does not directly support headers, Spring Cloud Stream provides its own mechanism of automatically wrapping outbound messages in an envelope of its own.
For middleware that does support headers, Spring Cloud Stream applications may receive messages with a given content type from non-Spring Cloud Stream applications.</p><p>The content type resolution process have been redesigned for Spring Cloud Stream 2.0.</p><p>Please read the migrating from 1.3 section to understand the changes when interacting with applications using versions of the framework.</p><p>The framework depends on a <code class="literal">contentType</code> to be present as a header in order to know how serialize/deserialize a payload.</p><p>Spring Cloud Stream allows you to declaratively configure type conversion for inputs and outputs using the <code class="literal">spring.cloud.stream.bindings.&lt;channelName&gt;.content-type</code> property of a binding.
Note that general type conversion may also be accomplished easily by using a transformer inside your application.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>For both input and output channel, setting a contentType via a property or via annotation only triggers the <code class="literal">default</code> converter if a message header with value <code class="literal">contentType</code> is not present.
This is useful for cases where you just want to send a <span class="emphasis"><em>POJO</em></span> without sending any header information, or to consume messages that do not have a <code class="literal">contentType</code> header present.
The framework will always override any default settings with the value found on the message headers.</p></td></tr></table></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>Although contentType became a required property, the framework will set a default value of <code class="literal">application/json</code> for all input/output channels if one is not
provided by the user.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mime-types" href="#mime-types"></a>28.1&nbsp;MIME types</h2></div></div></div><p>The <code class="literal">content-type</code> values are parsed as media types, e.g., <code class="literal">application/json</code> or <code class="literal">text/plain;charset=UTF-8</code>.</p><p>MIME types are especially useful for indicating how to convert to String or byte[] content.
Spring Cloud Stream also uses MIME type format to represent Java types, using the general type <code class="literal">application/x-java-object</code> with a <code class="literal">type</code> parameter.
For example, <code class="literal">application/x-java-object;type=java.util.Map</code> or <code class="literal">application/x-java-object;type=com.bar.Foo</code> can be set as the <code class="literal">content-type</code> property of an input binding.
In addition, Spring Cloud Stream provides custom MIME types, notably, <code class="literal">application/x-spring-tuple</code> to specify a Tuple.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mime-types-and-java-types" href="#mime-types-and-java-types"></a>28.2&nbsp;Channel contentType and Message Headers</h2></div></div></div><p>You can configure a message channel content type using <code class="literal">spring.cloud.stream.bindings.&lt;channelName&gt;.content-type</code> property, or using the <code class="literal">@Input</code> and <code class="literal">@Output</code> annotations.
By doing so, even if you send a POJO with no <code class="literal">contentType</code> information, the framework will set the MessageHeader <code class="literal">contentType</code> to the specified value set for the channel.</p><p>However, if you send a <code class="literal">Message&lt;T&gt;</code> and sets the <code class="literal">contentType</code> manually, that takes precedence over the configured property value.
This is valid for both input and output channels. The <code class="literal">MessageHeader</code> will always take precedence over the default configured <code class="literal">contentType</code> for the channel.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_contenttype_handling_for_output_channels" href="#_contenttype_handling_for_output_channels"></a>28.3&nbsp;ContentType handling for output channels</h2></div></div></div><p>Starting with version 2.0, the framework will no longer try to infer a contentType based on the payload <code class="literal">T</code> of a <code class="literal">Message&lt;T&gt;</code>.
It will instead use the contentType header (or the default provided by the framework) to configure the right <code class="literal">MessageConverter</code> to serialize the payload into <code class="literal">byte[]</code>.</p><p>The <code class="literal">contentType</code> you set is a hint to activate the corresponding <code class="literal">MessageConverter</code>. The converter can then modify the contentType to augment the information, such as the case with <code class="literal">Kryo</code> and <code class="literal">Avro</code> conveters.</p><p>For outbound messages, if your payload is of typ <code class="literal">byte[]</code>, the framework will skip the conversion logic, and just write those bytes to the wire.
In this case, if <code class="literal">contentType</code> of the message is absent,  it will set the default value specified to channel.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>If you intend to bypass conversion, just make sure you set the appropriate <code class="literal">contentType</code> header, otherwise you could be sending some arbitrary binary data, and the framework may set the header as <code class="literal">application/json</code> (default).</p></td></tr></table></div><p>The following snippet shows how you can bypass conversion and set the correct contentType header.</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> Source source;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> sendImageData(File f) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">byte</span>[] data = Files.readAllBytes(f.toPath());
    MimeType mimeType = (f.getName().endsWith(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"gif"</span>)) ? MimeTypeUtils.IMAGE_GIF : MimeTypeUtils.IMAGE_JPEG;
    source.output().send(MessageBuilder.withPayload(data)
            .setHeader(MessageHeaders.CONTENT_TYPE, mimeType)
            .build());
}</pre><p>Regardless of contentType used, the result is always a <code class="literal">Message&lt;byte[]&gt;</code> with a header <code class="literal">contentType</code> set. This is what gets passed to the binder to be sent over the wire.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"><col class="col_5"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><code class="literal">content-type</code> header</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">MessageConverter</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><code class="literal">content-type</code> augmented</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Supported types</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Comments</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/json</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>CustomMappingJackson2MessageConverter</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/json</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>POJO, primitives and Strings that represent JSON data</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>It&#8217;s the default converter if none is specified. Note that if you send a raw String it will be quoted</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>text/plain</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ObjectStringMessageConverter</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>text/plain</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Invokes <code class="literal">toString()</code> of the object</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/x-spring-tuple</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>TupleJsonMessageConverter</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/x-spring-tuple</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework.tuple.Tuple</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/x-java-serialized-object</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>JavaSerializationMessageConverter</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/x-java-serialized-object</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Any Java type that implements <code class="literal">Serializable</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>This converter uses java native serialization. Receivers of this data must have the same class on the classpath.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/x-java-object</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>KryoMessageConverter</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/x-java-object;type=&lt;Class being serialized&gt;</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Any Java type that can be serialized using Kryo</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Receivers of this data must have the same class on the classpath.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>application/avro</p></td><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>AvroMessageConverter</p></td><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>application/avro</p></td><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>A Generic or SpecificRecord from Avro types, a POJO if reflection is used</p></td><td style="" align="left" valign="top"><p>Avro needs an associated schema to write/read data. Please refer to the section on the docs on how to use it properly</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_contenttype_handling_for_input_channels" href="#_contenttype_handling_for_input_channels"></a>28.4&nbsp;ContentType handling for input channels</h2></div></div></div><p>For input channels, Spring Cloud Stream uses <code class="literal">@StreamListener</code> and <code class="literal">@ServiceActivator</code> content handling to support the conversion.
It does so by checking either the channel <code class="literal">content-type</code> set via <code class="literal">@Input(contentType="text/plain")</code> annotation or via <code class="literal">spring.cloud.stream.bindings.&lt;channel&gt;.contentType</code> property, or the presense of a header <code class="literal">contentType</code>.</p><p>The framework will check the contentType set for the Message, select the appropriate <code class="literal">MessageConverter</code> and apply conversion passing the argument as the target type.</p><p>If the converter does not support the target type it will return <code class="literal">null</code>, if <span class="strong"><strong>all</strong></span> configured converters return <code class="literal">null</code>, a <code class="literal">MessageConversionException</code> is thrown.</p><p>Just like output channels, if your method payload argument is of type <code class="literal">Message&lt;byte[]&gt;</code>, <code class="literal">byte[]</code> or <code class="literal">Message&lt;?&gt;</code> conversion is skipped and you get the raw bytes from the wire, plus the corresponding headers.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>Remember, the MessageHeader always takes precedence over the annotation or property configuration.</p></td></tr></table></div><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><code class="literal">content-type</code> header</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">MessageConverter</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Supported target type</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Comments</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/json</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>CustomMappingJackson2MessageConverter</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>POJO or String</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>text/plain</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ObjectStringMessageConverter</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>String</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/x-spring-tuple</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>TupleJsonMessageConverter</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>org.springframework.tuple.Tuple</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/x-java-serialized-object</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>JavaSerializationMessageConverter</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Any Java type that implements <code class="literal">Serializable</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/x-java-object</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>KryoMessageConverter</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Any Java type that can be serialized using Kryo</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>application/avro</p></td><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>AvroMessageConverter</p></td><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>A Generic or SpecificRecord from Avro types, a POJO if reflection is used</p></td><td style="" align="left" valign="top"><p>Avro needs an associated schema to write/read data. Please refer to the section on the docs on how to use it properly</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_customizing_message_conversion" href="#_customizing_message_conversion"></a>28.5&nbsp;Customizing message conversion</h2></div></div></div><p>Besides the conversions that it supports out of the box, Spring Cloud Stream also supports registering your own message conversion implementations.
This allows you to send and receive data in a variety of custom formats, including binary, and associate them with specific <code class="literal">contentTypes</code>.</p><p>Spring Cloud Stream registers all the beans of type <code class="literal">org.springframework.messaging.converter.MessageConverter</code> that are qualifeied using <code class="literal">@StreamConverter</code> annotation, as custom message converters along with the out of the box message converters.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The framework requires the <code class="literal">@StreamConverter</code> qualifier annotation to avoid picking up other converters that may be present on the <code class="literal">ApplicationContext</code> and could overlap with the default ones.</p></td></tr></table></div><p>If your message converter needs to work with a specific <code class="literal">content-type</code> and target class (for both input and output), then the message converter needs to extend <code class="literal">org.springframework.messaging.converter.AbstractMessageConverter</code>.
For conversion when using <code class="literal">@StreamListener</code>, a message converter that implements <code class="literal">org.springframework.messaging.converter.MessageConverter</code> would suffice.</p><p>Here is an example of creating a message converter bean (with the content-type <code class="literal">application/bar</code>) inside a Spring Cloud Stream application:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> SinkApplication {

    ...

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@StreamConverter</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageConverter customMessageConverter() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> MyCustomMessageConverter();
    }
}</pre><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyCustomMessageConverter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> AbstractMessageConverter {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MyCustomMessageConverter() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">super</span>(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> MimeType(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span>));
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> supports(Class&lt;?&gt; clazz) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> (Bar.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>.equals(clazz));
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> Object convertFromInternal(Message&lt;?&gt; message, Class&lt;?&gt; targetClass, Object conversionHint) {
        Object payload = message.getPayload();
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> (payload <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">instanceof</span> Bar ? payload : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Bar((<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">byte</span>[]) payload));
    }
}</pre><p>Spring Cloud Stream also provides support for Avro-based converters and schema evolution.
See <a class="link" href="multi_schema-evolution.html" title="29.&nbsp;Schema evolution support">the specific section</a> for details.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="__literal_streamlistener_literal_and_message_conversion" href="#__literal_streamlistener_literal_and_message_conversion"></a>28.6&nbsp;<code class="literal">@StreamListener</code> and Message Conversion</h2></div></div></div><p>The <code class="literal">@StreamListener</code> annotation provides a convenient way for converting incoming messages without the need to specify the content type of an input channel.
During the dispatching process to methods annotated with <code class="literal">@StreamListener</code>, a conversion will be applied automatically if the argument requires it.</p><p>For example, let&#8217;s consider a message with the String content <code class="literal">{"greeting":"Hello, world"}</code> and a <code class="literal">content-type</code> header of <code class="literal">application/json</code> is received on the input channel.
Let us consider the following application that receives it:</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> GreetingMessage {

  String greeting;

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String getGreeting() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> greeting;
  }

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setGreeting(String greeting) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.greeting = greeting;
  }
}

<em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> GreetingSink {

        <em><span class="hl-annotation" style="color: gray">@StreamListener(Sink.INPUT)</span></em>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> receive(Greeting greeting) {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// handle Greeting</span>
        }
    }</pre><p>The argument of the method will be populated automatically with the POJO containing the unmarshalled form of the JSON String.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="multi__configuration_options.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="multi__spring_cloud_stream.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="multi_schema-evolution.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">27.&nbsp;Configuration Options&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="multi_spring-cloud.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;29.&nbsp;Schema evolution support</td></tr></table></div></body></html>