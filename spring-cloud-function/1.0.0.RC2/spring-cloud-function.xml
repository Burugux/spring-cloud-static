<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Spring Cloud Function</title>
<date>2018-06-04</date>
</info>
<preface>
<title></title>
<simpara>Mark Fisher, Dave Syer</simpara>
<simpara><?asciidoc-hr?></simpara>
</preface>
<chapter xml:id="_introduction">
<title>Introduction</title>
<simpara>Spring Cloud Function is a project with the following high-level goals:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>Promote the implementation of business logic via functions.</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Decouple the development lifecycle of business logic from any specific runtime target so that the same code can run as a web endpoint, a stream processor, or a task.</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Support a uniform programming model across serverless providers, as well as the ability to run standalone (locally or in a PaaS).</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>Enable Spring Boot features (auto-configuration, dependency injection, metrics) on serverless providers.</emphasis></simpara>
</listitem>
</itemizedlist>
<simpara>It abstracts away all of the transport details and
infrastructure, allowing the developer to keep all the familiar tools
and processes, and focus firmly on business logic.</simpara>
<simpara>Here&#8217;s a complete, executable, testable Spring Boot application
(implementing a simple string manipulation):</simpara>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
public class Application {

  @Bean
  public Function&lt;Flux&lt;String&gt;, Flux&lt;String&gt;&gt; uppercase() {
    return flux -&gt; flux.map(value -&gt; value.toUpperCase());
  }

  public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
  }
}</programlisting>
<simpara>It&#8217;s just a Spring Boot application, so it can be built, run and
tested, locally and in a CI build, the same way as any other Spring
Boot application. The <literal>Function</literal> is from <literal>java.util</literal> and <literal>Flux</literal> is a
<link xl:href="http://www.reactive-streams.org/">Reactive Streams</link> <literal>Publisher</literal> from
<link xl:href="https://projectreactor.io/">Project Reactor</link>. The function can be
accessed over HTTP or messaging.</simpara>
<simpara>Spring Cloud Function has 4 main features:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Wrappers for <literal>@Beans</literal> of type <literal>Function</literal>, <literal>Consumer</literal> and
<literal>Supplier</literal>, exposing them to the outside world as either HTTP
endpoints and/or message stream listeners/publishers with RabbitMQ, Kafka etc.</simpara>
</listitem>
<listitem>
<simpara>Compiling strings which are Java function bodies into bytecode, and
then turning them into <literal>@Beans</literal> that can be wrapped as above.</simpara>
</listitem>
<listitem>
<simpara>Deploying a JAR file containing such an application context with an
isolated classloader, so that you can pack them together in a single
JVM.</simpara>
</listitem>
<listitem>
<simpara>Adapters for <link xl:href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-aws">AWS Lambda</link>, <link xl:href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-azure">Azure</link>, <link xl:href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-openwhisk">Apache OpenWhisk</link> and possibly other "serverless" service providers.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>Spring Cloud is released under the non-restrictive Apache 2.0 license. If you would like to contribute to this section of the documentation or if you find an error, please find the source code and issue trackers in the project at <link xl:href="https://github.com/spring-cloud/spring-cloud-function/tree/master/docs/src/main/asciidoc">github</link>.</simpara>
</note>
</chapter>
<chapter xml:id="_getting_started">
<title>Getting Started</title>
<simpara>Build from the command line (and "install" the samples):</simpara>
<screen>$ ./mvnw clean install</screen>
<simpara>(If you like to YOLO add <literal>-DskipTests</literal>.)</simpara>
<simpara>Run one of the samples, e.g.</simpara>
<screen>$ java -jar spring-cloud-function-samples/function-sample/target/*.jar</screen>
<simpara>This runs the app and exposes its functions over HTTP, so you can
convert a string to uppercase, like this:</simpara>
<screen>$ curl -H "Content-Type: text/plain" localhost:8080/uppercase -d Hello
HELLO</screen>
<simpara>You can convert multiple strings (a <literal>Flux&lt;String&gt;</literal>) by separating them
with new lines</simpara>
<screen>$ curl -H "Content-Type: text/plain" localhost:8080/uppercase -d 'Hello
&gt; World'
HELLOWORLD</screen>
<simpara>(You can use <literal><superscript>Q</superscript>J</literal> in a terminal to insert a new line in a literal
string like that.)</simpara>
</chapter>
<chapter xml:id="_building_and_running_a_function">
<title>Building and Running a Function</title>
<simpara>The sample <literal>@SpringBootApplication</literal> above has a function that can be
decorated at runtime by Spring Cloud Function to be an HTTP endpoint,
or a Stream processor, for instance with RabbitMQ, Apache Kafka or
JMS.</simpara>
<simpara>The <literal>@Beans</literal> can be <literal>Function</literal>, <literal>Consumer</literal> or <literal>Supplier</literal> (all from
<literal>java.util</literal>), and their parametric types can be String or POJO. A
<literal>Function</literal> is exposed as a Spring Cloud Stream <literal>Processor</literal> if
<literal>spring-cloud-function-stream</literal> is on the classpath.
A <literal>Consumer</literal> is also exposed as a Stream
<literal>Sink</literal> and a <literal>Supplier</literal> translates to a Stream <literal>Source</literal>.
HTTP endpoints are exposed if the Stream binder is <literal>spring-cloud-stream-binder-servlet</literal>.</simpara>
<simpara>Functions can be of <literal>Flux&lt;String&gt;</literal> or <literal>Flux&lt;Pojo&gt;</literal> and Spring Cloud
Function takes care of converting the data to and from the desired
types, as long as it comes in as plain text or (in the case of the
POJO) JSON. TBD: support for <literal>Flux&lt;Message&lt;Pojo&gt;&gt;</literal> and maybe plain
<literal>Pojo</literal> types (Fluxes implied and implemented by the framework).</simpara>
<simpara>Functions can be grouped together in a single application, or deployed
one-per-jar. It&#8217;s up to the developer to choose. An app with multiple
functions can be deployed multiple times in different "personalities",
exposing different functions over different physical transports.</simpara>
</chapter>
<chapter xml:id="_dynamic_compilation">
<title>Dynamic Compilation</title>
<simpara>There is a sample app that uses the function compiler to create a
function from a configuration property. The vanilla "function-sample"
also has that feature. And there are some examples that you can run to
see the compilation happening at run time. To run these examples,
change into the <literal>scripts</literal> directory:</simpara>
<screen>cd scripts</screen>
<simpara>Also, start a RabbitMQ server locally (e.g. execute <literal>rabbitmq-server</literal>).</simpara>
<section xml:id="_start_the_function_registry_service">
<title>Start the Function Registry Service:</title>
<screen>./function-registry.sh</screen>
</section>
<section xml:id="_register_a_function">
<title>Register a Function:</title>
<screen>./registerFunction.sh -n uppercase -f "f-&gt;f.map(s-&gt;s.toString().toUpperCase())"</screen>
</section>
<section xml:id="_run_a_rest_microservice_using_that_function">
<title>Run a REST Microservice using that Function:</title>
<screen>./web.sh -f uppercase -p 9000
curl -H "Content-Type: text/plain" -H "Accept: text/plain" localhost:9000/uppercase -d foo</screen>
</section>
<section xml:id="_register_a_supplier">
<title>Register a Supplier:</title>
<screen>./registerSupplier.sh -n words -f "()-&gt;Flux.just(\"foo\",\"bar\")"</screen>
</section>
<section xml:id="_run_a_rest_microservice_using_that_supplier">
<title>Run a REST Microservice using that Supplier:</title>
<screen>./web.sh -s words -p 9001
curl -H "Accept: application/json" localhost:9001/words</screen>
</section>
<section xml:id="_register_a_consumer">
<title>Register a Consumer:</title>
<screen>./registerConsumer.sh -n print -t String -f "System.out::println"</screen>
</section>
<section xml:id="_run_a_rest_microservice_using_that_consumer">
<title>Run a REST Microservice using that Consumer:</title>
<screen>./web.sh -c print -p 9002
curl -X POST -H "Content-Type: text/plain" -d foo localhost:9002/print</screen>
</section>
<section xml:id="_run_stream_processing_microservices">
<title>Run Stream Processing Microservices:</title>
<simpara>First register a streaming words supplier:</simpara>
<screen>./registerSupplier.sh -n wordstream -f "()-&gt;Flux.interval(Duration.ofMillis(1000)).map(i-&gt;\"message-\"+i)"</screen>
<simpara>Then start the source (supplier), processor (function), and sink (consumer) apps
(in reverse order):</simpara>
<screen>./stream.sh -p 9103 -i uppercaseWords -c print
./stream.sh -p 9102 -i words -f uppercase -o uppercaseWords
./stream.sh -p 9101 -s wordstream -o words</screen>
<simpara>The output will appear in the console of the sink app (one message per second, converted to uppercase):</simpara>
<screen>MESSAGE-0
MESSAGE-1
MESSAGE-2
MESSAGE-3
MESSAGE-4
MESSAGE-5
MESSAGE-6
MESSAGE-7
MESSAGE-8
MESSAGE-9
...</screen>
</section>
</chapter>
<chapter xml:id="_function_catalog_and_flexible_function_signatures">
<title>Function Catalog and Flexible Function Signatures</title>
<simpara>One of the main features of Spring Cloud Function is to adapt and
support a range of type signatures for user-defined functions. So
users can supply a bean of type <literal>Function&lt;String,String&gt;</literal>, for
instance, and the <literal>FunctionCatalog</literal> will wrap it into a
<literal>Function&lt;Flux&lt;String&gt;,Flux&lt;String&gt;&gt;</literal>. Users don&#8217;t normally have to
care about the <literal>FunctionCatalog</literal> at all, but it is useful to know what
kind of functions are supported in user code.</simpara>
<simpara>Generally speaking users can expect that if they write a function for
a plain old Java type (or primitive wrapper), then the function
catalog will wrap it to a <literal>Flux</literal> of the same type. If the user writes
a function using <literal>Message</literal> (from spring-messaging) it will receive and
transmit headers from any adapter that supports key-value metadata
(e.g. HTTP headers). Here are the details.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">User Function</entry>
<entry align="left" valign="top">Catalog Registration</entry>
<entry align="left" valign="top"></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Function&lt;S,T&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Function&lt;Flux&lt;S&gt;, Flux&lt;T&gt;&gt;</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Function&lt;Message&lt;S&gt;,Message&lt;T&gt;&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Function&lt;Flux&lt;Message&lt;S&gt;&gt;, Flux&lt;Message&lt;T&gt;&gt;&gt;</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Function&lt;Flux&lt;S&gt;, Flux&lt;T&gt;&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Function&lt;Flux&lt;S&gt;, Flux&lt;T&gt;&gt;</literal> (pass through)</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Supplier&lt;T&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Supplier&lt;Flux&lt;T&gt;&gt;</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Supplier&lt;Flux&lt;T&gt;&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Supplier&lt;Flux&lt;T&gt;&gt;</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Consumer&lt;T&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Function&lt;Flux&lt;T&gt;, Mono&lt;Void&gt;&gt;</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Consumer&lt;Message&lt;T&gt;&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Function&lt;Flux&lt;Message&lt;T&gt;&gt;, Mono&lt;Void&gt;&gt;</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Consumer&lt;Flux&lt;T&gt;&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Consumer&lt;Flux&lt;T&gt;&gt;</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Consumer is a little bit special because it has a <literal>void</literal> return type,
which implies blocking, at least potentially. Most likely you will not
need to write <literal>Consumer&lt;Flux&lt;?&gt;&gt;</literal>, but if you do need to do that,
remember to subscribe to the input flux. If you declare a <literal>Consumer</literal>
of a non publisher type (which is normal), it will be converted to a
function that returns a publisher, so that it can be subscribed to in
a controlled way.</simpara>
<simpara>A function catalog can contain a <literal>Supplier</literal> and a <literal>Function</literal> (or
<literal>Consumer</literal>) with the same name (like a GET and a POST to the same
resource). It can even contain a <literal>Consumer&lt;Flux&lt;&gt;&gt;</literal> with the same name
as a <literal>Function</literal>, but it cannot contain a <literal>Consumer&lt;T&gt;</literal> and a
<literal>Function&lt;T,S&gt;</literal> with the same name when <literal>T</literal> is not a <literal>Publisher</literal>
because the consumer would be converted to a <literal>Function</literal> and only one
of them can be registered.</simpara>
</chapter>
<chapter xml:id="_standalone_web_applications">
<title>Standalone Web Applications</title>
<simpara>The <literal>spring-cloud-function-web</literal> module has autoconfiguration that
activates when it is included in a Spring Boot web application (with
MVC support). There is also a <literal>spring-cloud-starter-function-web</literal> to
collect all the optional dependnecies in case you just want a simple
getting started experience.</simpara>
<simpara>With the web configurations activated your app will have an MVC
endpoint (on "/" by default, but configurable with
<literal>spring.cloud.function.web.path</literal>) that can be used to access the
functions in the application context. The supported content types are
plain text and JSON.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Method</entry>
<entry align="left" valign="top">Path</entry>
<entry align="left" valign="top">Request</entry>
<entry align="left" valign="top">Response</entry>
<entry align="left" valign="top">Status</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>GET</simpara></entry>
<entry align="left" valign="top"><simpara>/{supplier}</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>Items from the named supplier</simpara></entry>
<entry align="left" valign="top"><simpara>200 OK</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>POST</simpara></entry>
<entry align="left" valign="top"><simpara>/{consumer}</simpara></entry>
<entry align="left" valign="top"><simpara>JSON object or text</simpara></entry>
<entry align="left" valign="top"><simpara>Mirrors input and pushes request body into consumer</simpara></entry>
<entry align="left" valign="top"><simpara>202 Accepted</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>POST</simpara></entry>
<entry align="left" valign="top"><simpara>/{consumer}</simpara></entry>
<entry align="left" valign="top"><simpara>JSON array or text with new lines</simpara></entry>
<entry align="left" valign="top"><simpara>Mirrors input and pushes body into consumer one by one</simpara></entry>
<entry align="left" valign="top"><simpara>202 Accepted</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>POST</simpara></entry>
<entry align="left" valign="top"><simpara>/{function}</simpara></entry>
<entry align="left" valign="top"><simpara>JSON object or text</simpara></entry>
<entry align="left" valign="top"><simpara>The result of applying the named function</simpara></entry>
<entry align="left" valign="top"><simpara>200 OK</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>POST</simpara></entry>
<entry align="left" valign="top"><simpara>/{function}</simpara></entry>
<entry align="left" valign="top"><simpara>JSON array or text with new lines</simpara></entry>
<entry align="left" valign="top"><simpara>The result of applying the named function</simpara></entry>
<entry align="left" valign="top"><simpara>200 OK</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GET</simpara></entry>
<entry align="left" valign="top"><simpara>/{function}/{item}</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>Convert the item into an object and return the result of applying the function</simpara></entry>
<entry align="left" valign="top"><simpara>200 OK</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>As the table above shows the behaviour of the endpoint depends on the method and also the type of incoming request data. When the incoming data is single valued, and the target function is declared as obviously single valued (i.e. not returning a collection or <literal>Flux</literal>), then the response will also contain a single value. For multi-valued responses the client can ask for a server-sent event stream by sending `Accept: text/event-stream". If there is only one function (consumer etc.) then the name in the path is optional. Composite functions can be addressed using pipes or commas to separate function names (pipes are legal in URL paths, but a bit awkward to type on the command line).</simpara>
<simpara>Functions and consumers that are declared with input and output in <literal>Message&lt;?&gt;</literal> will see the request headers on the input messages, and the output message headers will be converted to HTTP headers.</simpara>
<simpara>When POSTing text the response format might be different with Spring Boot 2.0 and older versions, depending on the content negotiation (provide content type and accpt headers for the best results).</simpara>
</chapter>
<chapter xml:id="_standalone_streaming_applications">
<title>Standalone Streaming Applications</title>
<simpara>To send or receive messages from a broker (such as RabbitMQ or Kafka) you can use the <literal>spring-cloud-function-stream</literal> adapter. Add the adapter to your classpath along with the appropriate binder from Spring Cloud Stream. The adapter will bind to the message broker as a <literal>Processor</literal> (input and output streams) unless the user explicitly disables one or the other using <literal>spring.cloud.function.stream.{source,sink}.enabled=false</literal>.</simpara>
<simpara>An incoming message is routed to a function (or consumer). If there is only one, then the choice is obvious. If there are multiple functions that can accept an incoming message, the message is inspected to see if there is a <literal>stream_routekey</literal> header containing the name of a function. Routing headers or function names can be composed using a comma- or pipe-separated name. The header is also added to outgoing messages from a supplier. Messages with no route key can be routed exclusively to a function or consumer by specifying <literal>spring.cloud.function.stream.{processor,sink}.name</literal>. If a single function cannot be identified to process an incoming message there will be an error, unless you set <literal>spring.cloud.function.stream.shared=true</literal>, in which case such messages will be sent to all compatible functions. A single supplier can be chosen for output messages from a supplier (if more than one is available) using the <literal>spring.cloud.function.stream.source.name</literal>.</simpara>
<note>
<simpara>some binders will fail on startup if the message broker is not available and the function catalog contains suppliers that immediately produce messages when accessed. You can switch off the automatic publishing from suppliers on startup using the <literal>spring.cloud.function.strean.supplier.enabled=false</literal> flag.</simpara>
</note>
</chapter>
<chapter xml:id="_deploying_a_packaged_function">
<title>Deploying a Packaged Function</title>
<simpara>Spring Cloud Function provides a "deployer" library that allows you to launch a jar file (or exploded archive, or set of jar files) with an isolated class loader and expose the functions defined in it. This is quite a powerful tool that would allow you to, for instance, adapt a function to a range of different input-output adapters without changing the target jar file. Serverless platforms often have this kind of feature built in, so you could see it as a building block for a function invoker in such a platform (indeed the <link xl:href="https://projectriff.io">Riff</link> Java function invoker uses this library).</simpara>
<simpara>The standard entry point of the API is the Spring configuration annotation <literal>@EnableFunctionDeployer</literal>. If that is used in a Spring Boot application the deployer kicks in and looks for some configuration to tell it where to find the function jar. At a minimum the user has to provide a <literal>function.location</literal> which is a URL or resource location for the archive containing the functions. It can optionally use a <literal>maven:</literal> prefix to locate the artifact via a dependency lookup (see <literal>FunctionProperties</literal> for complete details). A Spring Boot application is bootstrapped from the jar file, using the <literal>MANIFEST.MF</literal> to locate a start class, so that a standard Spring Boot fat jar works well, for example. If the target jar can be launched successfully then the result is a function registered in the main application&#8217;s <literal>FunctionCatalog</literal>. The registered function can be applied by code in the main application, even though it was created in an isolated class loader (by deault).</simpara>
</chapter>
<chapter xml:id="_serverless_platform_adapters">
<title>Serverless Platform Adapters</title>
<simpara>As well as being able to run as a standalone process, a Spring Cloud
Function application can be adapted to run one of the existing
serverless platforms. In the project there are adapters for
<link xl:href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-aws">AWS
Lambda</link>,
<link xl:href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-azure">Azure</link>,
and
<link xl:href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-openwhisk">Apache
OpenWhisk</link>. The <link xl:href="https://github.com/fnproject/fn">Oracle Fn platform</link>
has its own Spring Cloud Function adapter. And
<link xl:href="https://projectriff.io">Riff</link> supports Java functions and its
<link xl:href="https://github.com/projectriff/java-function-invoker">Java Function
Invoker</link> acts natively is an adapter for Spring Cloud Function jars.</simpara>
<section xml:id="_aws_lambda">
<title>AWS Lambda</title>
<simpara>The <link xl:href="https://aws.amazon.com/">AWS</link> adapter takes a Spring Cloud Function app and converts it to a form that can run in AWS Lambda.</simpara>
<section xml:id="_introduction_2">
<title>Introduction</title>
<simpara>The adapter has a couple of generic request handlers that you can use. The most generic is <literal>SpringBootStreamHandler</literal>, which uses a Jackson <literal>ObjectMapper</literal> provided by Spring Boot to serialize and deserialize the objects in the function. There is also a <literal>SpringBootRequestHandler</literal> which you can extend, and provide the input and output types as type parameters (enabling AWS to inspect the class and do the JSON conversions itself).</simpara>
<simpara>If your app has more than one <literal>@Bean</literal> of type <literal>Function</literal> etc. then you can choose the one to use by configuring <literal>function.name</literal> (e.g. as <literal>FUNCTION_NAME</literal> environment variable in AWS). The functions are extracted from the Spring Cloud <literal>FunctionCatalog</literal> (searching first for <literal>Function</literal> then <literal>Consumer</literal> and finally <literal>Supplier</literal>).</simpara>
<section xml:id="_notes_on_jar_layout">
<title>Notes on JAR Layout</title>
<simpara>You don&#8217;t need the Spring Cloud Function Web or Stream adapter at runtime in Lambda, so you might need to exclude those before you create the JAR you send to AWS. A Lambda application has to be shaded, but a Spring Boot standalone application does not, so you can run the same app using 2 separate jars (as per the sample here). The sample app creates 2 jar files, one with an <literal>aws</literal> classifier for deploying in Lambda, and one executable (thin) jar that includes <literal>spring-cloud-function-web</literal> at runtime. Spring Cloud Function will try and locate a "main class" for you from the JAR file manifest, using the <literal>Start-Class</literal> attribute (which will be added for you by the Spring Boot tooling if you use the starter parent). If there is no <literal>Start-Class</literal> in your manifest you can use an environment variable <literal>MAIN_CLASS</literal> when you deploy the function to AWS.</simpara>
</section>
</section>
<section xml:id="_build">
<title>Build</title>
<screen>./mvnw -U clean package</screen>
</section>
<section xml:id="_upload">
<title>Upload</title>
<simpara>Build the sample under <literal>spring-cloud-function-samples/function-sample-aws</literal> and upload the <literal>-aws</literal> jar file to Lambda. The handler can be <literal>example.Handler</literal> or <literal>org.springframework.cloud.function.adapter.aws.SpringBootStreamHandler</literal> (FQN of the class, <emphasis>not</emphasis> a method reference, although Lambda does accept method references).</simpara>
<simpara>Using the AWS command line tools it looks like this:</simpara>
<screen>aws lambda create-function --function-name Uppercase --role arn:aws:iam::[USERID]:role/service-role/[ROLE] --zip-file fileb://function-sample-aws/target/function-sample-aws-1.0.0.BUILD-SNAPSHOT-aws.jar --handler org.springframework.cloud.function.adapter.aws.SpringBootStreamHandler --description "Spring Cloud Function Adapter Example" --runtime java8 --region us-east-1 --timeout 30 --memory-size 1024 --publish</screen>
<simpara>The input type for the function in the AWS sample is a Foo with a single property called "value". So you would need this to test it:</simpara>
<screen>{
  "value": "test"
}</screen>
</section>
</section>
<section xml:id="_azure_functions">
<title>Azure Functions</title>
<simpara>The <link xl:href="https://azure.microsoft.com">Azure</link> adapter bootstraps a Spring Cloud Function context and channels function calls from the Azure framework into the user functions, using Spring Boot configuration where necessary. Azure Functions has quite a unique, but invasive programming model, involving annotations in user code that are specific to the platform. The Spring Cloud Function Azure adapter trades the convenience of these annotations for portability of the function implementations. Instead of using the annotations you have to write some JSON by hand (at least for now) to guide the platform to call the right methods in the adapter.</simpara>
<simpara>The adapter has a generic http request handler that you can use.
There is a <literal>AzureSpringBootRequestHandler</literal> which you must extend, and provide the input and output types as type parameters (enabling Azure to inspect the class and do the JSON conversions itself).</simpara>
<simpara>If your app has more than one <literal>@Bean</literal> of type <literal>Function</literal> etc. then you can choose the one to use by configuring <literal>function.name</literal>.
The functions are extracted from the Spring Cloud <literal>FunctionCatalog</literal>.</simpara>
<section xml:id="_notes_on_jar_layout_2">
<title>Notes on JAR Layout</title>
<simpara>You don&#8217;t need the Spring Cloud Function Web at runtime in Azure, so you need to exclude this before you create the JAR you deploy to Azure.
A function application on Azure has to be shaded, but a Spring Boot standalone application does not, so you can run the same app using 2 separate jars (as per the sample here).
The sample app creates the shaded jar file, with an <literal>azure</literal> classifier for deploying in Azure.</simpara>
</section>
<section xml:id="_json_configuration">
<title>JSON Configuration</title>
<simpara>The Azure tooling needs to find some JSON configuration files to tell it how to deploy and integrate the function (e.g. which Java class to use as the entry point, and which triggers to use). Those files can be created with the Maven plugin for a non-Spring function, but the tooling doesn&#8217;t work yet with the adapter in its current form. There is an example <literal>function.json</literal> in the sample which hooks the function up as an HTTP endpoint:</simpara>
<screen>{
  "scriptFile" : "../function-sample-azure-1.0.0.BUILD-SNAPSHOT-azure.jar",
  "entryPoint" : "example.FooHandler.execute",
  "bindings" : [ {
    "type" : "httpTrigger",
    "name" : "foo",
    "direction" : "in",
    "authLevel" : "anonymous",
    "methods" : [ "get", "post" ]
  }, {
    "type" : "http",
    "name" : "$return",
    "direction" : "out"
  } ],
  "disabled" : false
}</screen>
</section>
<section xml:id="_build_2">
<title>Build</title>
<screen>./mvnw -U clean package</screen>
</section>
<section xml:id="_running_the_sample">
<title>Running the sample</title>
<simpara>You can run the sample locally, just like the other Spring Cloud Function samples:</simpara>
<simpara><?asciidoc-hr?></simpara>
<simpara><?asciidoc-hr?></simpara>
<simpara>and <literal>curl -H "Content-Type: text/plain" localhost:8080/function -d '{"value": "hello foobar"}'</literal>.</simpara>
<simpara>You will need the <literal>az</literal> CLI app and some node.js fu (see <link xl:href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-java-maven">https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-java-maven</link> for more detail). To deploy the function on Azure runtime:</simpara>
<screen>$ az login
$ mvn azure-functions:deploy</screen>
<simpara>On another terminal try this: <literal>curl <link xl:href="https://&lt;azure-function-url-from-the-log&gt;/api/uppercase">https://&lt;azure-function-url-from-the-log&gt;/api/uppercase</link> -d '{"value": "hello foobar!"}'</literal>. Please ensure that you use the right URL for the function above. Alternatively you can test the function in the Azure Dashboard UI (click on the function name, go to the right hand side and click "Test" and to the bottom right, "Run").</simpara>
<simpara>The input type for the function in the Azure sample is a Foo with a single property called "value". So you need this to test it with something like below:</simpara>
<screen>{
  "value": "foobar"
}</screen>
</section>
</section>
<section xml:id="_apache_openwhisk">
<title>Apache Openwhisk</title>
<simpara>The <link xl:href="https://openwhisk.apache.org/">OpenWhisk</link> adapter is in the form of an executable jar that can be used in a a docker image to be deployed to Openwhisk. The platform works in request-response mode, listening on port 8080 on a specific endpoint, so the adapter is a simple Spring MVC application.</simpara>
<section xml:id="_quick_start">
<title>Quick Start</title>
<simpara>Implement a POF (be sure to use the <literal>functions</literal> package):</simpara>
<screen>package functions;

import java.util.function.Function;

public class Uppercase implements Function&lt;String, String&gt; {

	public String apply(String input) {
		return input.toUpperCase();
	}
}</screen>
<simpara>Install it into your local Maven repository:</simpara>
<screen>./mvnw clean install</screen>
<simpara>Create a <literal>function.properties</literal> file that provides its Maven coordinates. For example:</simpara>
<screen>dependencies.function: com.example:pof:0.0.1-SNAPSHOT</screen>
<simpara>Copy the openwhisk runner JAR to the working directory (same directory as the properties file):</simpara>
<screen>cp spring-cloud-function-adapters/spring-cloud-function-adapter-openwhisk/target/spring-cloud-function-adapter-openwhisk-1.0.0.BUILD-SNAPSHOT.jar runner.jar</screen>
<simpara>Generate a m2 repo from the <literal>--thin.dryrun</literal> of the runner JAR with the above properties file:</simpara>
<screen>java -jar -Dthin.root=m2 runner.jar --thin.name=function --thin.dryrun</screen>
<simpara>Use the following Dockerfile:</simpara>
<screen>FROM openjdk:8-jdk-alpine
VOLUME /tmp
COPY m2 /m2
ADD runner.jar .
ADD function.properties .
ENV JAVA_OPTS=""
ENTRYPOINT [ "java", "-Djava.security.egd=file:/dev/./urandom", "-jar", "runner.jar", "--thin.root=/m2", "--thin.name=function", "--function.name=uppercase"]
EXPOSE 8080</screen>
<blockquote>
<note>
<simpara>you could use a Spring Cloud Function app, instead of just a jar with a POF in it, in which case you would have to change the way the app runs in the container so that it picks up the main class as a source file. For example, you could change the <literal>ENTRYPOINT</literal> above and add <literal>--spring.main.sources=com.example.SampleApplication</literal>.</simpara>
</note>
</blockquote>
<simpara>Build the Docker image:</simpara>
<screen>docker build -t [username/appname] .</screen>
<simpara>Push the Docker image:</simpara>
<screen>docker push [username/appname]</screen>
<simpara>Use the OpenWhisk CLI (e.g. after <literal>vagrant ssh</literal>) to create the action:</simpara>
<screen>wsk action create example --docker [username/appname]</screen>
<simpara>Invoke the action:</simpara>
<screen>wsk action invoke example --result --param payload foo
{
    "result": "FOO"
}</screen>
</section>
</section>
</chapter>
</book>