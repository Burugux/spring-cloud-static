<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>32.&nbsp;Content Type negotiation</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="multi_spring-cloud.html" title="Spring Cloud"><link rel="up" href="multi__spring_cloud_stream.html" title="Part&nbsp;V.&nbsp;Spring Cloud Stream"><link rel="prev" href="multi__configuration_options.html" title="31.&nbsp;Configuration Options"><link rel="next" href="multi_schema-evolution.html" title="33.&nbsp;Schema evolution support"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">32.&nbsp;Content Type negotiation</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="multi__configuration_options.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;V.&nbsp;Spring Cloud Stream</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="multi_schema-evolution.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="contenttypemanagement" href="#contenttypemanagement"></a>32.&nbsp;Content Type negotiation</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_introduction" href="#_introduction"></a>32.1&nbsp;Introduction</h2></div></div></div><p>Data transformation is one of the core features of any message-driven microservice architecture. Given that in Spring Cloud Stream, such data
is represented as a Spring <code class="literal">Message</code>, such message may have to be transformed to a desired shape/size before reaching its destination. This is required for two reasons:</p><p><span class="emphasis"><em>1. To convert the contents of the incoming message to match the signature of the application-provided handler.</em></span></p><p><span class="emphasis"><em>2. To convert the contents of the outgoing message to the wire format.</em></span></p><p>The wire format is typically <code class="literal">byte[]</code> (i.e., Kafka and Rabbit binders), but is governed by the binder implementation.</p><p>In Spring Cloud Stream, message transformation is accomplished with a <code class="literal">org.springframework.messaging.converter.MessageConverter</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>As a supplement to the details to follow you may also want to read the following
<a class="link" href="https://spring.io/blog/2018/02/26/spring-cloud-stream-2-0-content-type-negotiation-and-transformation" target="_top">blog</a></p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_mechanics" href="#_mechanics"></a>32.2&nbsp;Mechanics</h2></div></div></div><p>To better understand the mechanics and the necessity behind content-type negotiation let&#8217;s look at the very simple use case using the following message
handler as an example. Also let&#8217;s assume that this is the only handler in the application (no internal pipeline) for simplicity.</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@StreamListener(Processor.INPUT)</span></em>
<em><span class="hl-annotation" style="color: gray">@SendTo(Processor.OUTPUT)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String handle(Person person) {..}</pre><p>The above handler expects <code class="literal">Person</code> type as an argument and will produce <code class="literal">String</code> type as an output. In order for the framework to succeed in passing the incoming
<code class="literal">Message</code> as an argument to this handler it has to somehow transform the payload of the <code class="literal">Message</code> from the wire format to <code class="literal">Person</code> type.
In other words the framework must locate and apply the appropriate <code class="literal">MessageConverter</code>. To accomplish that the framework needs some instructions
from the user. One of these instructions is already provided by the signature of the handler method itself (<code class="literal">Person</code> type), so in theory, that should and in some
cases is enough, but for the majority of the use cases in order to select the appropriate <code class="literal">MessageConverter</code> the framework needs an additional piece of information.
That missing piece is <code class="literal">contentType</code>.</p><p>Spring Cloud Stream provides three simple mechanisms to define <code class="literal">contentType</code> and they all come with precedence order:</p><p><span class="emphasis"><em>1. <span class="strong"><strong><span class="strong"><strong>HEADER</strong></span></strong></span> - the <code class="literal">contentType</code> can be communicated through the Message itself. By simply providing <code class="literal">contentType</code> header you are declaring the content type to use to locate and
apply the appropriate MessageConverter.</em></span></p><p><span class="emphasis"><em>2. <span class="strong"><strong><span class="strong"><strong>BINDING</strong></span></strong></span> - the <code class="literal">contentType</code> can be set per destination binding via <code class="literal">spring.cloud.stream.bindings.input.content-type</code> property. NOTE: the segment <code class="literal">input</code> in the property name
corresponds to the actual name of the destination which is &#8220;input&#8221; in our case. This approach allows one to declare per-binding the content type to use to locate and
apply the appropriate MessageConverter.</em></span></p><p><span class="emphasis"><em>3. <span class="strong"><strong><span class="strong"><strong>DEFAULT</strong></span></strong></span> - in the event <code class="literal">contentType</code> is not present in the Message header and/or binding, the default <code class="literal">application/json</code> content type will be used to
locate and apply the appropriate MessageConverter.</em></span></p><p>As mentioned, the above also demonstrates the order of precedence in the event there is a tie. For example, header provided content type takes precedence over any other content type.
The same applies for content type set per binding which essentially allows one to override the default content type. But it also provides a sensible default which was determined from
the community feedback.</p><p>Another reason for making <code class="literal">application/json</code> the default stems from the interoperability requirements driven by distributed microservices architectures where producer and consumer not only
run in different JVMs, but can also run on different non-JVM platforms.</p><p>Once the non-void handler method returns and unless the return value is already a <code class="literal">Message</code>, the new <code class="literal">Message</code> is constructed with return vlaue as the payload while inheriting
headers from the input <code class="literal">Message</code> less the ones defined/filtered by <code class="literal">SpringIntegrationProperties.messageHandlerNotPropagatedHeaders</code>.
By default, there is only one header set there - <code class="literal">contentType</code>. This means that the new <code class="literal">Message</code> will not have <code class="literal">contentType</code> header set, thus ensuring that the <code class="literal">contentType</code>
can evolve. You can always opt out to returning a <code class="literal">Message</code> from the handler method where you can inject any header you wish.</p><p>If there is an internal pipeline the <code class="literal">Message</code> is sent to the next handler going through the same process of conversion, or if there is no internal
 pipeline or you&#8217;ve reached the end of it the <code class="literal">Message</code> is sent back to the output destination.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_content_type_vs_argument_type" href="#_content_type_vs_argument_type"></a>32.2.1&nbsp;Content type vs. argument type</h3></div></div></div><p>As it was mentioned, for the framework to select the appropriate MessageConverter it requires <span class="emphasis"><em>argument type</em></span> and optionally <span class="emphasis"><em>content type</em></span> information.
The logic for selecting the appropriate <code class="literal">MessageConverter</code> resides with the argument resolvers (<code class="literal">HandlerMethodArgumentResolvers</code>), right before the invocation of the user
defined handler method (that is when the actual argument type is known to the framework).
If argument type does NOT match the type of the current payload the framework delegates to the stack of the
pre-configured <code class="literal">MessageConverters</code> to see if any one of them can convert the payload. As you can see the  <code class="literal">Object fromMessage(Message&lt;?&gt; message, Class&lt;?&gt; targetClass);</code>
operation of the MessageConverter takes <code class="literal">targetClass</code> as one of its arguments. The framework also ensures that the provided <code class="literal">Message</code> always contains <code class="literal">contentType</code> header
in the event one was not there already (injects the default one or the one set per binding).
That is the mechanism by which framework determines if message can be converted to a target type - <code class="literal">contentType</code> and argumenyt type.
If no appropriate <code class="literal">MessageConverter</code> is found the exception is thrown at which time you can add custom <code class="literal">MessageConverter</code> (more on this later).</p><p>But what if the payload type matches the target type declared by the handler method? In this cases there is obviously nothing to convert and the
payload will be passed unmodified. While this sounds pretty straight forward and logical, keep in mind handler methods that take <code class="literal">Message&lt;?&gt;</code> and/or <code class="literal">Object</code> as an
argument. By doing so you are essentially forfeiting the conversion process by declaring the target type to be <code class="literal">Object</code> which is an <code class="literal">instanceof</code> everything in Java.</p><p>In other words:</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Do NOT expect Message to be converted into some type based on the <code class="literal">contentType</code> only. Remember that the <code class="literal">contentType</code> is complimentary to the target type.
A hint if you wish which <code class="literal">MessageConverter</code> may or may not take into consideration.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_message_converters" href="#_message_converters"></a>32.2.2&nbsp;Message Converters</h3></div></div></div><p><code class="literal">MessageConverters</code> define two methods:</p><pre class="programlisting">Object fromMessage(Message&lt;?&gt; message, Class&lt;?&gt; targetClass);

Message&lt;?&gt; toMessage(Object payload, <em><span class="hl-annotation" style="color: gray">@Nullable</span></em> MessageHeaders headers);</pre><p>It is important to understand the contract of these methods and their usage specifically in the context of Spring Cloud Stream.</p><p>The <code class="literal">fromMessage</code> method converts incoming <code class="literal">Message</code> to an argument type. The payload of the <code class="literal">Message</code> could be <span class="emphasis"><em>any type</em></span> and it&#8217;s
up to the actual implementation of the <code class="literal">MessageConverter</code> to support multiple types. For example, some JSON converter may support the payload type as <code class="literal">byte[]</code>
and <code class="literal">String</code> etc. This is important when application contains an internal pipeline (i.e., <span class="emphasis"><em>input &#8594; handler1 &#8594; handler2 &#8594;. . . &#8594; output</em></span>) and the output of
the upstream handler results in a <code class="literal">Message</code> which may not be in the initial wire format.</p><p>However. . .</p><p>The <code class="literal">toMessage</code> method has a more strict contract and must always convert <code class="literal">Message</code> to the wire format - <code class="literal">byte[]</code>.</p><p>So for all intents and purposes (and especially when implementing your own converter) you might as well look at them as:</p><pre class="programlisting">Object fromMessage(Message&lt;?&gt; message, Class&lt;?&gt; targetClass);

Message&lt;<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">byte</span>[]&gt; toMessage(Object payload, <em><span class="hl-annotation" style="color: gray">@Nullable</span></em> MessageHeaders headers);</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_provided_messageconverters" href="#_provided_messageconverters"></a>32.3&nbsp;Provided MessageConverters</h2></div></div></div><p>As it was mentioned earlier the framework already provides a stack of <code class="literal">MessageConverters</code> to handle most common use cases. Below is the ordered list of provided <code class="literal">MessageConverters</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>It is important to understand the importance of the order since the mechanism by which the framework locates the appropriate <code class="literal">MessageConverter</code> is by iterating through each and asking
if it can convert using the first one that can convert.</p></td></tr></table></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><code class="literal">ApplicationJsonMessageMarshallingConverter</code> - <span class="emphasis"><em>variation of the <code class="literal">org.springframework.messaging.converter.MappingJackson2MessageConverter</code>. Supports conversion of the payload of the
<code class="literal">Message</code> from <code class="literal">String</code> or <code class="literal">byte[]</code>.</em></span></li><li class="listitem"><code class="literal">TupleJsonMessageConverter</code> - <span class="emphasis"><em><span class="strong"><strong><span class="strong"><strong>[DEPRECATED]</strong></span></strong></span> Supports conversion of the payload of the <code class="literal">Message</code> from <code class="literal">org.springframework.tuple.Tuple</code>.</em></span></li><li class="listitem"><code class="literal">ByteArrayMessageConverter</code> - <span class="emphasis"><em>Supports conversion of the payload of the <code class="literal">Message</code> from <code class="literal">byte[]</code> to <code class="literal">byte[]</code> for cases when <code class="literal">contentType</code> is set to <code class="literal">application/octet-stream</code>.
Essentially a pass through and exists primarily for backward compatibility.</em></span></li><li class="listitem"><code class="literal">ObjectStringMessageConverter</code> - <span class="emphasis"><em>Supports conversion of any type to a <code class="literal">String</code>, when contentType is <code class="literal">text/plain</code>. Invokes Object&#8217;s <code class="literal">toString()</code> method or if payload is
<code class="literal">byte[]</code> then new <code class="literal">String(byte[])</code>.</em></span></li><li class="listitem"><code class="literal">JavaSerializationMessageConverter</code> - <span class="emphasis"><em><span class="strong"><strong><span class="strong"><strong>[DEPRECATED]</strong></span></strong></span> Supports conversion based on java serialization when <code class="literal">contentType</code> is <code class="literal">application/x-java-serialized-object</code>.</em></span></li><li class="listitem"><code class="literal">KryoMessageConverter</code> - <span class="emphasis"><em><span class="strong"><strong><span class="strong"><strong>[DEPRECATED]</strong></span></strong></span> Supports conversion based on kryo serialization when <code class="literal">contentType</code> is <code class="literal">application/x-java-object</code>.</em></span></li><li class="listitem"><code class="literal">JsonUnmarshallingConverter</code> - <span class="emphasis"><em>Similar to the <code class="literal">ApplicationJsonMessageMarshallingConverter</code>. Supports conversion of any type when <code class="literal">contentType</code> is <code class="literal">application/x-java-object</code>.
Expects the actual type information to be embedded in the <code class="literal">contentType</code> as an attribute (e.g., <code class="literal">application/x-java-object;type=foo.bar.Baz</code>).</em></span></li></ol></div><p>In the event no appropriate converter is found the framework will throw an exception at which point you should check your code and configfuration and ensure you didn&#8217;t miss anything
(i.e., provide <code class="literal">contentType</code> via binding or header). However, most likely you are dealing with some uncommon case (custom <code class="literal">contentType</code> perhaps) and the current stack of provided <code class="literal">MessageConverters</code>
doesn&#8217;t know how to convert. And if that&#8217;s the case you can add custom <code class="literal">MessageConverter</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_user_defined_message_converters" href="#_user_defined_message_converters"></a>32.4&nbsp;User defined Message Converters</h2></div></div></div><p>Spring Cloud Stream exposes a mechanism to define and register additional <code class="literal">MessageConverters</code>. All you need to do is implement <code class="literal">org.springframework.messaging.converter.MessageConverter</code>,
confiure it as <code class="literal">@Bean</code> and annotate it with <code class="literal">@StreamMessageConverter</code> and it will be added to the existing stack of <code class="literal">MessageConverters</code>. The <code class="literal">@StreamMessageConverter</code> qualifier annotation
is to avoid picking up other converters that may be present on the <span class="emphasis"><em>Application Context</em></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>It is important to undetrstand that custom <code class="literal">MessageConverters</code> are added to the head of the existing stack.
This allows custom <code class="literal">MessageConverters</code> to take precedence over the existing ones, thus supporting not only addition, but the override of the existing ones.</p></td></tr></table></div><p>Here is an example of creating a message converter bean to support new content type <code class="literal">application/bar</code>:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> SinkApplication {

    ...

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@StreamConverter</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageConverter customMessageConverter() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> MyCustomMessageConverter();
    }
}</pre><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyCustomMessageConverter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> AbstractMessageConverter {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MyCustomMessageConverter() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">super</span>(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> MimeType(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span>));
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> supports(Class&lt;?&gt; clazz) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> (Bar.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>.equals(clazz));
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> Object convertFromInternal(Message&lt;?&gt; message, Class&lt;?&gt; targetClass, Object conversionHint) {
        Object payload = message.getPayload();
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> (payload <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">instanceof</span> Bar ? payload : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Bar((<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">byte</span>[]) payload));
    }
}</pre><p>Spring Cloud Stream also provides support for Avro-based converters and schema evolution.
See <a class="link" href="multi_schema-evolution.html" title="33.&nbsp;Schema evolution support">the specific section</a> for details.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="multi__configuration_options.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="multi__spring_cloud_stream.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="multi_schema-evolution.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">31.&nbsp;Configuration Options&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="multi_spring-cloud.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;33.&nbsp;Schema evolution support</td></tr></table></div></body></html>