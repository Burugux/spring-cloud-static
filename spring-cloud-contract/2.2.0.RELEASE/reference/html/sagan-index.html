<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>Features</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>

</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_features">Features</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud Contract is an umbrella project holding solutions that help users in successfully implementing the Consumer Driven Contracts approach. Currently Spring Cloud Contract consists of the Spring Cloud Contract Verifier project.</p>
</div>
<div class="paragraph">
<p>Spring Cloud Contract Verifier is a tool that enables Consumer Driven Contract (CDC) development of JVM-based applications. It is shipped with Contract Definition Language (DSL) written in Groovy or YAML. Contract definitions are used to produce following resources:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>by default JSON stub definitions to be used by WireMock (HTTP Server Stub) when doing integration testing on the client code (client tests). Test code must still be written by hand, test data is produced by Spring Cloud Contract Verifier.</p>
</li>
<li>
<p>Messaging routes if you’re using one. We’re integrating with Spring Integration, Spring Cloud Stream and Apache Camel. You can however set your own integrations if you want to.</p>
</li>
<li>
<p>Acceptance tests (by default in JUnit or Spock) used to verify if server-side implementation of the API is compliant with the contract (server tests). Full test is generated by Spring Cloud Contract Verifier.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Cloud Contract Verifier moves TDD to the level of software architecture.</p>
</div>
<div class="paragraph">
<p>To see how Spring Cloud Contract supports other languages just check out <a href="https://spring.io/blog/2018/02/13/spring-cloud-contract-in-a-polyglot-world">this blog post</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_features"><a class="link" href="#_features">Features</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>When trying to test an application that communicates with other services then we could do one of two things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>deploy all microservices and perform end to end tests</p>
</li>
<li>
<p>mock other microservices in unit / integration tests</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both have their advantages but also a lot of disadvantages. Let’s focus on the latter.
Deploy all microservices and perform end to end tests</p>
</div>
<div class="paragraph">
<p>Advantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>simulates production</p>
</li>
<li>
<p>tests real communication between services</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Disadvantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>to test one microservice we would have to deploy 6 microservices, a couple of databases etc.</p>
</li>
<li>
<p>the environment where the tests would be conducted would be locked for a single suite of tests (i.e. nobody else would be able to run the tests in the meantime).</p>
</li>
<li>
<p>long to run</p>
</li>
<li>
<p>very late feedback</p>
</li>
<li>
<p>extremely hard to debug</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Mock other microservices in unit / integration tests</p>
</div>
<div class="paragraph">
<p>Advantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>very fast feedback</p>
</li>
<li>
<p>no infrastructure requirements</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Disadvantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the implementor of the service creates stubs thus they might have nothing to do with the reality</p>
</li>
<li>
<p>you can go to production with passing tests and failing production</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To solve the aforementioned issues Spring Cloud Contract Verifier with Stub Runner were created. Their main idea is to give you very fast feedback, without the need to set up the whole world of microservices.</p>
</div>
<div class="paragraph">
<p>Spring Cloud Contract Verifier features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ensure that HTTP / Messaging stubs (used when developing the client) are doing exactly what actual server-side implementation will do</p>
</li>
<li>
<p>promote acceptance test driven development method and Microservices architectural style</p>
</li>
<li>
<p>to provide a way to publish changes in contracts that are immediately visible on both sides of the communication</p>
</li>
<li>
<p>to generate boilerplate test code used on the server side</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/atom-one-dark-reasonable.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>