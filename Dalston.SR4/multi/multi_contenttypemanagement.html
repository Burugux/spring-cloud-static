<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>28.&nbsp;Content Type and Transformation</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="multi_spring-cloud.html" title="Spring Cloud"><link rel="up" href="multi__spring_cloud_stream.html" title="Part&nbsp;IV.&nbsp;Spring Cloud Stream"><link rel="prev" href="multi__configuration_options.html" title="27.&nbsp;Configuration Options"><link rel="next" href="multi_schema-evolution.html" title="29.&nbsp;Schema evolution support"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">28.&nbsp;Content Type and Transformation</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="multi__configuration_options.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;IV.&nbsp;Spring Cloud Stream</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="multi_schema-evolution.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="contenttypemanagement" href="#contenttypemanagement"></a>28.&nbsp;Content Type and Transformation</h2></div></div></div><p>To allow you to propagate information about the content type of produced messages, Spring Cloud Stream attaches, by default, a <code class="literal">contentType</code> header to outbound messages.
For middleware that does not directly support headers, Spring Cloud Stream provides its own mechanism of automatically wrapping outbound messages in an envelope of its own.
For middleware that does support headers, Spring Cloud Stream applications may receive messages with a given content type from non-Spring Cloud Stream applications.</p><p>Spring Cloud Stream can handle messages based on this information in two ways:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Through its <code class="literal">contentType</code> settings on inbound and outbound channels</li><li class="listitem">Through its argument mapping performed for methods annotated with <code class="literal">@StreamListener</code></li></ul></div><p>Spring Cloud Stream allows you to declaratively configure type conversion for inputs and outputs using the <code class="literal">spring.cloud.stream.bindings.&lt;channelName&gt;.content-type</code> property of a binding.
Note that general type conversion may also be accomplished easily by using a transformer inside your application.
Currently, Spring Cloud Stream natively supports the following type conversions commonly used in streams:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="strong"><strong>JSON</strong></span> to/from <span class="strong"><strong>POJO</strong></span></li><li class="listitem"><span class="strong"><strong>JSON</strong></span> to/from <a class="link" href="https://github.com/spring-projects/spring-tuple/blob/master/spring-tuple/src/main/java/org/springframework/tuple/Tuple.java" target="_top">org.springframework.tuple.Tuple</a></li><li class="listitem"><span class="strong"><strong>Object</strong></span> to/from <span class="strong"><strong>byte[]</strong></span> : Either the raw bytes serialized for remote transport, bytes emitted by an application, or converted to bytes using Java serialization(requires the object to be Serializable)</li><li class="listitem"><span class="strong"><strong>String</strong></span> to/from <span class="strong"><strong>byte[]</strong></span></li><li class="listitem"><span class="strong"><strong>Object</strong></span> to <span class="strong"><strong>plain text</strong></span> (invokes the object&#8217;s <span class="emphasis"><em>toString()</em></span> method)</li></ul></div><p>Where <span class="emphasis"><em>JSON</em></span> represents either a byte array or String payload containing JSON.
Currently, Objects may be converted from a JSON byte array or String.
Converting to JSON always produces a String.</p><p>If no <code class="literal">content-type</code> property is set on an outbound channel, Spring Cloud Stream will serialize the payload using a serializer based on the <a class="link" href="https://github.com/EsotericSoftware/kryo" target="_top">Kryo</a> serialization framework.
Deserializing messages at the destination requires the payload class to be present on the receiver&#8217;s classpath.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mime-types" href="#mime-types"></a>28.1&nbsp;MIME types</h2></div></div></div><p><code class="literal">content-type</code> values are parsed as media types, e.g., <code class="literal">application/json</code> or <code class="literal">text/plain;charset=UTF-8</code>.
MIME types are especially useful for indicating how to convert to String or byte[] content.
Spring Cloud Stream also uses MIME type format to represent Java types, using the general type <code class="literal">application/x-java-object</code> with a <code class="literal">type</code> parameter.
For example, <code class="literal">application/x-java-object;type=java.util.Map</code> or <code class="literal">application/x-java-object;type=com.bar.Foo</code> can be set as the <code class="literal">content-type</code> property of an input binding.
In addition, Spring Cloud Stream provides custom MIME types, notably, <code class="literal">application/x-spring-tuple</code> to specify a Tuple.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mime-types-and-java-types" href="#mime-types-and-java-types"></a>28.2&nbsp;MIME types and Java types</h2></div></div></div><p>The type conversions Spring Cloud Stream provides out of the box are summarized in the following table:
'Source Payload' means the payload before conversion and 'Target Payload' means the 'payload' after conversion.
The type conversion can occur either on the 'producer' side (output) or at the 'consumer' side (input).</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"><col class="col_5"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Source Payload</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Target Payload</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><code class="literal">content-type</code> header (source message)</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><code class="literal">content-type</code> header (after conversion)</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Comments</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>POJO</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>JSON String</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ignored</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/json</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Tuple</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>JSON String</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ignored</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/json</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>JSON is tailored for Tuple</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>POJO</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>String (toString())</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ignored</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>text/plain, java.lang.String</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>POJO</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>byte[] (java.io serialized)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ignored</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/x-java-serialized-object</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>JSON byte[] or String</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>POJO</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/json (or none)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/x-java-object</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>byte[] or String</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Serializable</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/x-java-serialized-object</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/x-java-object</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>JSON byte[] or String</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Tuple</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/json (or none)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>application/x-spring-tuple</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>byte[]</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>String</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>any</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>text/plain, java.lang.String</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>will apply any Charset specified in the content-type header</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>String</p></td><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>byte[]</p></td><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>any</p></td><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>application/octet-stream</p></td><td style="" align="left" valign="top"><p>will apply any Charset specified in the content-type header</p></td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Conversion applies to payloads that require type conversion.
For example, if an application produces an XML string with outputType=application/json, the payload will not be converted from XML to JSON.
This is because the payload send to the outbound channel is already a String so no conversion will be applied at runtime.
It is also important to note that when using the default serialization mechanism, the payload class must be shared between the sending and receiving application, and compatible with the binary content.
This can create issues when application code changes independently in the two applications, as the binary format and code may become incompatible.</p></td></tr></table></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>While conversion is supported for both inbound and outbound channels, it is especially recommended to be used for the conversion of outbound messages.
For the conversion of inbound messages, especially when the target is a POJO, the <code class="literal">@StreamListener</code> support will perform the conversion automatically.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_customizing_message_conversion" href="#_customizing_message_conversion"></a>28.3&nbsp;Customizing message conversion</h2></div></div></div><p>Besides the conversions that it supports out of the box, Spring Cloud Stream also supports registering your own message conversion implementations.
This allows you to send and receive data in a variety of custom formats, including binary, and associate them with specific <code class="literal">contentTypes</code>.
Spring Cloud Stream registers all the beans of type <code class="literal">org.springframework.messaging.converter.MessageConverter</code> as custom message converters along with the out of the box message converters.</p><p>If your message converter needs to work with a specific <code class="literal">content-type</code> and target class (for both input and output), then the message converter needs to extend <code class="literal">org.springframework.messaging.converter.AbstractMessageConverter</code>.
For conversion when using <code class="literal">@StreamListener</code>, a message converter that implements <code class="literal">org.springframework.messaging.converter.MessageConverter</code> would suffice.</p><p>Here is an example of creating a message converter bean (with the content-type <code class="literal">application/bar</code>) inside a Spring Cloud Stream application:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> SinkApplication {

  ...

  <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageConverter customMessageConverter() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> MyCustomMessageConverter();
  }</pre><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyCustomMessageConverter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> AbstractMessageConverter {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MyCustomMessageConverter() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">super</span>(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> MimeType(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span>));
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> supports(Class&lt;?&gt; clazz) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> (Bar.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> == clazz);
  }

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> Object convertFromInternal(Message&lt;?&gt; message, Class&lt;?&gt; targetClass, Object conversionHint) {
		Object payload = message.getPayload();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> (payload <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">instanceof</span> Bar ? payload : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Bar((<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">byte</span>[]) payload));
	}
}</pre><p>Spring Cloud Stream also provides support for Avro-based converters and schema evolution.
See <a class="link" href="multi_schema-evolution.html" title="29.&nbsp;Schema evolution support">the specific section</a> for details.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="__literal_streamlistener_literal_and_message_conversion" href="#__literal_streamlistener_literal_and_message_conversion"></a>28.4&nbsp;<code class="literal">@StreamListener</code> and Message Conversion</h2></div></div></div><p>The <code class="literal">@StreamListener</code> annotation provides a convenient way for converting incoming messages without the need to specify the content type of an input channel.
During the dispatching process to methods annotated with <code class="literal">@StreamListener</code>, a conversion will be applied automatically if the argument requires it.</p><p>For example, let&#8217;s consider a message with the String content <code class="literal">{"greeting":"Hello, world"}</code> and a <code class="literal">content-type</code> header of <code class="literal">application/json</code> is received on the input channel.
Let us consider the following application that receives it:</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> GreetingMessage {

  String greeting;

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String getGreeting() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> greeting;
  }

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setGreeting(String greeting) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.greeting = greeting;
  }
}

<em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> GreetingSink {

		<em><span class="hl-annotation" style="color: gray">@StreamListener(Sink.INPUT)</span></em>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> receive(Greeting greeting) {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// handle Greeting</span>
		}
	}</pre><p>The argument of the method will be populated automatically with the POJO containing the unmarshalled form of the JSON String.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="multi__configuration_options.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="multi__spring_cloud_stream.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="multi_schema-evolution.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">27.&nbsp;Configuration Options&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="multi_spring-cloud.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;29.&nbsp;Schema evolution support</td></tr></table></div></body></html>